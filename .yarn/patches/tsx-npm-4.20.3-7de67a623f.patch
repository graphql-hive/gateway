diff --git a/dist/esm/index.cjs b/dist/esm/index.cjs
index ba1ee8a4096285d73f854416fbb75e34fa372464..21bb90941ee4a38f16cf7e418ac8fc4ef6867925 100755
--- a/dist/esm/index.cjs
+++ b/dist/esm/index.cjs
@@ -1,2 +1,2 @@
 "use strict";var S=Object.defineProperty;var l=(e,t)=>S(e,"name",{value:t,configurable:!0});var _=require("node:worker_threads"),m=require("../node-features-roYmp9jK.cjs"),F=require("../register-2sWVXuRQ.cjs");require("../get-pipe-path-BoR10qr8.cjs"),require("node:module");var p=require("node:path"),g=require("node:url");require("get-tsconfig");var s=require("../register-D46fvsV_.cjs"),E=require("node:fs");require("esbuild"),require("node:crypto");var f=require("../index-gckBtVBf.cjs"),v=require("../client-D6NvIMSC.cjs");require("../require-D4F1Lv60.cjs");var L=require("node:fs/promises");require("module"),require("../temporary-directory-B83uKxJF.cjs"),require("node:os"),require("node:util"),require("../index-BWFBUo6r.cjs"),require("node:net");const u={active:!0},b=l(async e=>{if(!e)throw new Error(`tsx must be loaded with --import instead of --loader
-The --loader flag was deprecated in Node v20.6.0 and v18.19.0`);u.namespace=e.namespace,e.tsconfig!==!1&&s.loadTsconfig(e.tsconfig??process.env.TSX_TSCONFIG_PATH),e.port&&(u.port=e.port,e.port.on("message",t=>{t==="deactivate"&&(u.active=!1,e.port.postMessage({type:"deactivated"}))}))},"initialize"),J=l(()=>(s.loadTsconfig(process.env.TSX_TSCONFIG_PATH),"process.setSourceMapsEnabled(true);"),"globalPreload"),h=new Map,M=l(async e=>{if(h.has(e))return h.get(e);if(!await E.promises.access(e).then(()=>!0,()=>!1)){h.set(e,void 0);return}const n=await E.promises.readFile(e,"utf8");try{const r=JSON.parse(n);return h.set(e,r),r}catch{throw new Error(`Error parsing: ${e}`)}},"readPackageJson"),N=l(async e=>{let t=new URL("package.json",e);for(;!t.pathname.endsWith("/node_modules/package.json");){const n=g.fileURLToPath(t),r=await M(n);if(r)return r;const a=t;if(t=new URL("../package.json",t),t.pathname===a.pathname)break}},"findPackageJson"),O=l(async e=>(await N(e))?.type??"commonjs","getPackageType"),A=l(e=>{[e]=e.split("?");const t=p.extname(e);if(t===".mts")return"module";if(t===".cts")return"commonjs"},"getFormatFromExtension"),W=l(e=>{const t=A(e);if(t)return t;const{pathname:n}=new URL(e),r=p.extname(n);if(s.tsExtensions.includes(r))return O(e)},"getFormatFromFileUrl"),P="tsx-namespace=",y=l(e=>{const t=e.indexOf(P);if(t===-1)return;const n=e[t-1];if(n!=="?"&&n!=="&")return;const r=t+P.length,a=e.indexOf("&",r);return a===-1?e.slice(r):e.slice(r,a)},"getNamespace"),R=m.isFeatureSupported(m.importAttributes)?"importAttributes":"importAssertions";if(exports.load=async(e,t,n)=>{if(!u.active)return n(e,t);const r=y(e);if(u.namespace&&u.namespace!==r)return n(e,t);if(u.port){const o=new URL(e);o.searchParams.delete("tsx-namespace"),u.port.postMessage({type:"load",url:o.toString()})}if(v.parent.send&&v.parent.send({type:"dependency",path:e}),s.isJsonPattern.test(e)){let o=t[R];o||(o={},t[R]=o),o.type||(o.type="json")}const a=await n(e,t);s.logEsm(3,"loaded by next loader",{url:e,loaded:a});const i=e.startsWith(s.fileUrlPrefix)?g.fileURLToPath(e):e;if(a.format==="commonjs"&&m.isFeatureSupported(m.esmLoadReadFile)&&a.responseURL?.startsWith("file:")&&!i.endsWith(".cjs")){const o=await L.readFile(new URL(e),"utf8");if(!i.endsWith(".js")||f.isESM(o)){const d=f.transformSync(o,i,{tsconfigRaw:s.fileMatcher?.(i)}),T=r?`${i}?namespace=${encodeURIComponent(r)}`:i;return a.responseURL=`data:text/javascript,${encodeURIComponent(d.code)}?filePath=${encodeURIComponent(T)}`,s.logEsm(3,"returning CJS export annotation",a),a}}if(!a.source)return a;const c=a.source.toString();if(a.format==="json"||s.tsExtensionsPattern.test(e)){const o=await f.transform(c,i,{tsconfigRaw:p.isAbsolute(i)?s.fileMatcher?.(i):void 0});return{format:"module",source:s.inlineSourceMap(o)}}if(a.format==="module"){const o=f.transformDynamicImport(i,c);o&&(a.source=s.inlineSourceMap(o))}return a},s.debugEnabled){const e=exports.load;exports.load=async(t,n,r)=>{s.logEsm(2,"load",{url:t,context:n});const a=await e(t,n,r);return s.logEsm(1,"loaded",{url:t,result:a}),a}}const U=l(e=>{if(e.url)return e.url;const t=e.message.match(/^Cannot find module '([^']+)'/);if(t){const[,r]=t;return r}const n=e.message.match(/^Cannot find package '([^']+)'/);if(n){const[,r]=n;if(!p.isAbsolute(r))return;const a=g.pathToFileURL(r);if(a.pathname.endsWith("/")&&(a.pathname+="package.json"),a.pathname.endsWith("/package.json")){const i=f.readJsonFile(a);if(i?.main)return new URL(i.main,a).toString()}else return a.toString()}},"getMissingPathFromNotFound"),w=l(async(e,t,n,r)=>{const a=s.mapTsExtensions(e);if(s.logEsm(3,"resolveExtensions",{url:e,context:t,throwError:r,tryPaths:a}),!a)return;let i;for(const c of a)try{return await n(c,t)}catch(o){const{code:d}=o;if(d!=="ERR_MODULE_NOT_FOUND"&&d!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw o;i=o}if(r)throw i},"resolveExtensions"),j=l(async(e,t,n)=>{if(s.logEsm(3,"resolveBase",{specifier:e,context:t,specifierStartsWithFileUrl:e.startsWith(s.fileUrlPrefix),isRelativePath:s.isRelativePath(e),tsExtensionsPattern:s.tsExtensionsPattern.test(t.parentURL),allowJs:s.allowJs}),(e.startsWith(s.fileUrlPrefix)||s.isRelativePath(e))&&(s.tsExtensionsPattern.test(t.parentURL)||s.allowJs)){const r=await w(e,t,n);if(s.logEsm(3,"resolveBase resolved",{specifier:e,context:t,resolved:r}),r)return r}try{return await n(e,t)}catch(r){if(s.logEsm(3,"resolveBase error",{specifier:e,context:t,error:r}),r instanceof Error){const a=r;if(a.code==="ERR_MODULE_NOT_FOUND"){const i=U(a);if(i){const c=await w(i,t,n);if(c)return c}}}throw r}},"resolveBase"),q=l(async(e,t,n)=>{if(s.logEsm(3,"resolveDirectory",{specifier:e,context:t,isDirectory:s.isDirectoryPattern.test(e)}),(e==="."||e===".."||e.endsWith("/.."))&&(e+="/"),s.isDirectoryPattern.test(e)){const r=new URL(e,t.parentURL);return r.pathname=p.join(r.pathname,"index"),await w(r.toString(),t,n,!0)}try{return await j(e,t,n)}catch(r){if(r instanceof Error){s.logEsm(3,"resolveDirectory error",{specifier:e,context:t,error:r});const a=r;if(a.code==="ERR_UNSUPPORTED_DIR_IMPORT"){const i=U(a);if(i)try{return await w(`${i}/index`,t,n,!0)}catch(c){const o=c,{message:d}=o;throw o.message=o.message.replace(`${"/index".replace("/",p.sep)}'`,"'"),o.stack=o.stack.replace(d,o.message),o}}}throw r}},"resolveDirectory"),D=l(async(e,t,n)=>{if(s.logEsm(3,"resolveTsPaths",{specifier:e,context:t,requestAcceptsQuery:s.requestAcceptsQuery(e),tsconfigPathsMatcher:s.tsconfigPathsMatcher,fromNodeModules:t.parentURL?.includes("/node_modules/")}),!s.requestAcceptsQuery(e)&&s.tsconfigPathsMatcher&&!t.parentURL?.includes("/node_modules/")){const r=s.tsconfigPathsMatcher(e);s.logEsm(3,"resolveTsPaths",{possiblePaths:r});for(const a of r)try{return await q(g.pathToFileURL(a).toString(),t,n)}catch{}}return q(e,t,n)},"resolveTsPaths"),k="tsx://";if(exports.resolve=async(e,t,n)=>{if(!u.active||e.startsWith("node:"))return n(e,t);let r=y(e)??(t.parentURL&&y(t.parentURL));if(u.namespace){let o;if(e.startsWith(k)){try{o=JSON.parse(e.slice(k.length))}catch{}o?.namespace&&(r=o.namespace)}if(u.namespace!==r)return n(e,t);o&&(e=o.specifier,t.parentURL=o.parentURL)}const[a,i]=e.split("?"),c=await D(a,t,n);return s.logEsm(2,"nextResolve",{resolved:c}),c.format==="builtin"||(!c.format&&c.url.startsWith(s.fileUrlPrefix)&&(c.format=await W(c.url),s.logEsm(2,"getFormatFromFileUrl",{resolved:c,format:c.format})),i&&(c.url+=`?${i}`),r&&!c.url.includes(P)&&(c.url+=(c.url.includes("?")?"&":"?")+P+r)),c},s.debugEnabled){const e=exports.resolve;exports.resolve=async(t,n,r)=>{s.logEsm(2,"resolve",{specifier:t,context:n});const a=await e(t,n,r);return s.logEsm(1,"resolved",{specifier:t,context:n,result:a}),a}}m.isFeatureSupported(m.moduleRegister)&&_.isMainThread&&F.register(),exports.globalPreload=J,exports.initialize=b;
+The --loader flag was deprecated in Node v20.6.0 and v18.19.0`);u.namespace=e.namespace,e.tsconfig!==!1&&s.loadTsconfig(e.tsconfig??process.env.TSX_TSCONFIG_PATH),e.port&&(u.port=e.port,e.port.on("message",t=>{t==="deactivate"&&(u.active=!1,e.port.postMessage({type:"deactivated"}))}))},"initialize"),J=l(()=>(s.loadTsconfig(process.env.TSX_TSCONFIG_PATH),"process.setSourceMapsEnabled(true);"),"globalPreload"),h=new Map,M=l(async e=>{if(h.has(e))return h.get(e);if(!await E.promises.access(e).then(()=>!0,()=>!1)){h.set(e,void 0);return}const n=await E.promises.readFile(e,"utf8");try{const r=JSON.parse(n);return h.set(e,r),r}catch{throw new Error(`Error parsing: ${e}`)}},"readPackageJson"),N=l(async e=>{let t=new URL("package.json",e);for(;!t.pathname.endsWith("/node_modules/package.json");){const n=g.fileURLToPath(t),r=await M(n);if(r)return r;const a=t;if(t=new URL("../package.json",t),t.pathname===a.pathname)break}},"findPackageJson"),O=l(async e=>(await N(e))?.type??"commonjs","getPackageType"),A=l(e=>{[e]=e.split("?");const t=p.extname(e);if(t===".mts")return"module";if(t===".cts")return"commonjs"},"getFormatFromExtension"),W=l(e=>{const t=A(e);if(t)return t;const{pathname:n}=new URL(e),r=p.extname(n);if(s.tsExtensions.includes(r))return O(e)},"getFormatFromFileUrl"),P="tsx-namespace=",y=l(e=>{const t=e.indexOf(P);if(t===-1)return;const n=e[t-1];if(n!=="?"&&n!=="&")return;const r=t+P.length,a=e.indexOf("&",r);return a===-1?e.slice(r):e.slice(r,a)},"getNamespace"),R=m.isFeatureSupported(m.importAttributes)?"importAttributes":"importAssertions";if(exports.load=async(e,t,n)=>{if(!u.active)return n(e,t);const r=y(e);if(u.namespace&&u.namespace!==r)return n(e,t);if(u.port){const o=new URL(e);o.searchParams.delete("tsx-namespace"),u.port.postMessage({type:"load",url:o.toString()})}if(v.parent.send&&v.parent.send({type:"dependency",path:e}),s.isJsonPattern.test(e)){let o=t[R];o||(o={},t[R]=o),o.type||(o.type="json")}const a=await n(e,t);s.logEsm(3,"loaded by next loader",{url:e,loaded:a});const i=e.startsWith(s.fileUrlPrefix)?g.fileURLToPath(e):e;if(a.format==="commonjs"&&m.isFeatureSupported(m.esmLoadReadFile)&&a.responseURL?.startsWith("file:")&&!i.endsWith(".cjs")){const o=await L.readFile(new URL(e),"utf8");if(!i.endsWith(".js")||f.isESM(o)){const d=f.transformSync(o,i,{tsconfigRaw:s.fileMatcher?.(i)}),T=r?`${i}?namespace=${encodeURIComponent(r)}`:i;return a.responseURL=`data:text/javascript,${encodeURIComponent(d.code)}?filePath=${encodeURIComponent(T)}`,s.logEsm(3,"returning CJS export annotation",a),a}}if(!a.source)return a;const c=a.source.toString();if(a.format==="json"||s.tsExtensionsPattern.test(e)){const o=await f.transform(c,i,{tsconfigRaw:p.isAbsolute(i)?s.fileMatcher?.(i):void 0});return{format:"module",source:s.inlineSourceMap(o)}}if(a.format==="module"){const o=f.transformDynamicImport(i,c);o&&(a.source=s.inlineSourceMap(o))}return a},s.debugEnabled){const e=exports.load;exports.load=async(t,n,r)=>{s.logEsm(2,"load",{url:t,context:n});const a=await e(t,n,r);return s.logEsm(1,"loaded",{url:t,result:a}),a}}const U=l(e=>{if(e.url)return e.url;const t=e.message.match(/^Cannot find module '([^']+)'/);if(t){const[,r]=t;return r}const n=e.message.match(/^Cannot find package '([^']+)'/);if(n){const[,r]=n;if(!p.isAbsolute(r))return;const a=g.pathToFileURL(r);if(a.pathname.endsWith("/")&&(a.pathname+="package.json"),a.pathname.endsWith("/package.json")){const i=f.readJsonFile(a);if(i?.main)return new URL(i.main,a).toString()}else return a.toString()}},"getMissingPathFromNotFound"),w=l(async(e,t,n,r)=>{const a=s.mapTsExtensions(e);if(s.logEsm(3,"resolveExtensions",{url:e,context:t,throwError:r,tryPaths:a}),!a)return;let i;for(const c of a)try{return await n(c,t)}catch(o){const{code:d}=o;if(d!=="ERR_MODULE_NOT_FOUND"&&d!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw o;i=o}if(r)throw i},"resolveExtensions"),j=l(async(e,t,n)=>{if(s.logEsm(3,"resolveBase",{specifier:e,context:t,specifierStartsWithFileUrl:e.startsWith(s.fileUrlPrefix),isRelativePath:s.isRelativePath(e),tsExtensionsPattern:s.tsExtensionsPattern.test(t.parentURL),allowJs:s.allowJs}),(e.startsWith(s.fileUrlPrefix)||s.isRelativePath(e))&&(s.tsExtensionsPattern.test(t.parentURL)||s.allowJs)){const r=await w(e,t,n);if(s.logEsm(3,"resolveBase resolved",{specifier:e,context:t,resolved:r}),r)return r}try{return await n(e,t)}catch(r){if(s.logEsm(3,"resolveBase error",{specifier:e,context:t,error:r}),r instanceof Error){const a=r;if(a.code==="ERR_MODULE_NOT_FOUND"){const i=U(a);if(i){const c=await w(i,t,n);if(c)return c}}}throw r}},"resolveBase"),q=l(async(e,t,n)=>{if(s.logEsm(3,"resolveDirectory",{specifier:e,context:t,isDirectory:s.isDirectoryPattern.test(e)}),(e==="."||e===".."||e.endsWith("/.."))&&(e+="/"),s.isDirectoryPattern.test(e)){const r=new URL(e,t.parentURL);return r.pathname=p.join(r.pathname,"index"),await w(r.toString(),t,n,!0)}try{return await j(e,t,n)}catch(r){if(r instanceof Error){s.logEsm(3,"resolveDirectory error",{specifier:e,context:t,error:r});const a=r;if(a.code==="ERR_UNSUPPORTED_DIR_IMPORT"){const i=U(a);if(i)try{return await w(`${i}/index`,t,n,!0)}catch(c){const o=c,{message:d}=o;throw o.message=o.message.replace(`${"/index".replace("/",p.sep)}'`,"'"),o.stack=o.stack.replace(d,o.message),o}}}throw r}},"resolveDirectory"),D=l(async(e,t,n)=>{if(s.logEsm(3,"resolveTsPaths",{specifier:e,context:t,requestAcceptsQuery:s.requestAcceptsQuery(e),tsconfigPathsMatcher:s.tsconfigPathsMatcher,fromNodeModules:t.parentURL?.includes("/node_modules/")}),!s.requestAcceptsQuery(e)&&s.tsconfigPathsMatcher){const r=s.tsconfigPathsMatcher(e);s.logEsm(3,"resolveTsPaths",{possiblePaths:r});for(const a of r)try{return await q(g.pathToFileURL(a).toString(),t,n)}catch{}}return q(e,t,n)},"resolveTsPaths"),k="tsx://";if(exports.resolve=async(e,t,n)=>{if(!u.active||e.startsWith("node:"))return n(e,t);let r=y(e)??(t.parentURL&&y(t.parentURL));if(u.namespace){let o;if(e.startsWith(k)){try{o=JSON.parse(e.slice(k.length))}catch{}o?.namespace&&(r=o.namespace)}if(u.namespace!==r)return n(e,t);o&&(e=o.specifier,t.parentURL=o.parentURL)}const[a,i]=e.split("?"),c=await D(a,t,n);return s.logEsm(2,"nextResolve",{resolved:c}),c.format==="builtin"||(!c.format&&c.url.startsWith(s.fileUrlPrefix)&&(c.format=await W(c.url),s.logEsm(2,"getFormatFromFileUrl",{resolved:c,format:c.format})),i&&(c.url+=`?${i}`),r&&!c.url.includes(P)&&(c.url+=(c.url.includes("?")?"&":"?")+P+r)),c},s.debugEnabled){const e=exports.resolve;exports.resolve=async(t,n,r)=>{s.logEsm(2,"resolve",{specifier:t,context:n});const a=await e(t,n,r);return s.logEsm(1,"resolved",{specifier:t,context:n,result:a}),a}}m.isFeatureSupported(m.moduleRegister)&&_.isMainThread&&F.register(),exports.globalPreload=J,exports.initialize=b;
diff --git a/dist/esm/index.mjs b/dist/esm/index.mjs
index 3525121aebf2866c969ac362e08caf672dde8b7e..54337dc9e18772fce526e2e46eb955ecfc485d19 100755
--- a/dist/esm/index.mjs
+++ b/dist/esm/index.mjs
@@ -1,2 +1,2 @@
 var C=Object.defineProperty;var c=(t,e)=>C(t,"name",{value:e,configurable:!0});import{isMainThread as $}from"node:worker_threads";import{i as y,a as q,e as B,m as G}from"../node-features-_8ZFwP_x.mjs";import{r as H}from"../register-B7jrtLTO.mjs";import"../get-pipe-path-BHW2eJdv.mjs";import"node:module";import l from"node:path";import{fileURLToPath as k,pathToFileURL as E}from"node:url";import"get-tsconfig";import{l as T,t as Q,b as X,d as m,f,e as w,g as S,h as _,j as L,k as F,m as P,n as b,o as z,p as J,q as N}from"../register-CFH5oNdT.mjs";import O from"node:fs";import"esbuild";import"node:crypto";import{i as K,a as V,t as Y,b as Z,r as x}from"../index-7AaEi15b.mjs";import{p as j}from"../client-BQVF1NaW.mjs";import"../require-DQxpCAr4.mjs";import{readFile as tt}from"node:fs/promises";import"module";import"../temporary-directory-CwHp0_NW.mjs";import"node:os";import"node:util";import"../index-gbaejti9.mjs";import"node:net";const p={active:!0},et=c(async t=>{if(!t)throw new Error(`tsx must be loaded with --import instead of --loader
-The --loader flag was deprecated in Node v20.6.0 and v18.19.0`);p.namespace=t.namespace,t.tsconfig!==!1&&T(t.tsconfig??process.env.TSX_TSCONFIG_PATH),t.port&&(p.port=t.port,t.port.on("message",e=>{e==="deactivate"&&(p.active=!1,t.port.postMessage({type:"deactivated"}))}))},"initialize"),at=c(()=>(T(process.env.TSX_TSCONFIG_PATH),"process.setSourceMapsEnabled(true);"),"globalPreload"),u=new Map,st=c(async t=>{if(u.has(t))return u.get(t);if(!await O.promises.access(t).then(()=>!0,()=>!1)){u.set(t,void 0);return}const r=await O.promises.readFile(t,"utf8");try{const a=JSON.parse(r);return u.set(t,a),a}catch{throw new Error(`Error parsing: ${t}`)}},"readPackageJson"),rt=c(async t=>{let e=new URL("package.json",t);for(;!e.pathname.endsWith("/node_modules/package.json");){const r=k(e),a=await st(r);if(a)return a;const s=e;if(e=new URL("../package.json",e),e.pathname===s.pathname)break}},"findPackageJson"),ot=c(async t=>(await rt(t))?.type??"commonjs","getPackageType"),nt=c(t=>{[t]=t.split("?");const e=l.extname(t);if(e===".mts")return"module";if(e===".cts")return"commonjs"},"getFormatFromExtension"),it=c(t=>{const e=nt(t);if(e)return e;const{pathname:r}=new URL(t),a=l.extname(r);if(Q.includes(a))return ot(t)},"getFormatFromFileUrl"),h="tsx-namespace=",R=c(t=>{const e=t.indexOf(h);if(e===-1)return;const r=t[e-1];if(r!=="?"&&r!=="&")return;const a=e+h.length,s=t.indexOf("&",a);return s===-1?t.slice(a):t.slice(a,s)},"getNamespace"),W=y(q)?"importAttributes":"importAssertions";let U=c(async(t,e,r)=>{if(!p.active)return r(t,e);const a=R(t);if(p.namespace&&p.namespace!==a)return r(t,e);if(p.port){const o=new URL(t);o.searchParams.delete("tsx-namespace"),p.port.postMessage({type:"load",url:o.toString()})}if(j.send&&j.send({type:"dependency",path:t}),X.test(t)){let o=e[W];o||(o={},e[W]=o),o.type||(o.type="json")}const s=await r(t,e);m(3,"loaded by next loader",{url:t,loaded:s});const n=t.startsWith(f)?k(t):t;if(s.format==="commonjs"&&y(B)&&s.responseURL?.startsWith("file:")&&!n.endsWith(".cjs")){const o=await tt(new URL(t),"utf8");if(!n.endsWith(".js")||K(o)){const d=V(o,n,{tsconfigRaw:S?.(n)}),I=a?`${n}?namespace=${encodeURIComponent(a)}`:n;return s.responseURL=`data:text/javascript,${encodeURIComponent(d.code)}?filePath=${encodeURIComponent(I)}`,m(3,"returning CJS export annotation",s),s}}if(!s.source)return s;const i=s.source.toString();if(s.format==="json"||w.test(t)){const o=await Y(i,n,{tsconfigRaw:l.isAbsolute(n)?S?.(n):void 0});return{format:"module",source:_(o)}}if(s.format==="module"){const o=Z(n,i);o&&(s.source=_(o))}return s},"load");if(L){const t=U;U=c(async(e,r,a)=>{m(2,"load",{url:e,context:r});const s=await t(e,r,a);return m(1,"loaded",{url:e,result:s}),s},"load")}const A=c(t=>{if(t.url)return t.url;const e=t.message.match(/^Cannot find module '([^']+)'/);if(e){const[,a]=e;return a}const r=t.message.match(/^Cannot find package '([^']+)'/);if(r){const[,a]=r;if(!l.isAbsolute(a))return;const s=E(a);if(s.pathname.endsWith("/")&&(s.pathname+="package.json"),s.pathname.endsWith("/package.json")){const n=x(s);if(n?.main)return new URL(n.main,s).toString()}else return s.toString()}},"getMissingPathFromNotFound"),g=c(async(t,e,r,a)=>{const s=z(t);if(m(3,"resolveExtensions",{url:t,context:e,throwError:a,tryPaths:s}),!s)return;let n;for(const i of s)try{return await r(i,e)}catch(o){const{code:d}=o;if(d!=="ERR_MODULE_NOT_FOUND"&&d!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw o;n=o}if(a)throw n},"resolveExtensions"),ct=c(async(t,e,r)=>{if(m(3,"resolveBase",{specifier:t,context:e,specifierStartsWithFileUrl:t.startsWith(f),isRelativePath:J(t),tsExtensionsPattern:w.test(e.parentURL),allowJs:N}),(t.startsWith(f)||J(t))&&(w.test(e.parentURL)||N)){const a=await g(t,e,r);if(m(3,"resolveBase resolved",{specifier:t,context:e,resolved:a}),a)return a}try{return await r(t,e)}catch(a){if(m(3,"resolveBase error",{specifier:t,context:e,error:a}),a instanceof Error){const s=a;if(s.code==="ERR_MODULE_NOT_FOUND"){const n=A(s);if(n){const i=await g(n,e,r);if(i)return i}}}throw a}},"resolveBase"),M=c(async(t,e,r)=>{if(m(3,"resolveDirectory",{specifier:t,context:e,isDirectory:b.test(t)}),(t==="."||t===".."||t.endsWith("/.."))&&(t+="/"),b.test(t)){const a=new URL(t,e.parentURL);return a.pathname=l.join(a.pathname,"index"),await g(a.toString(),e,r,!0)}try{return await ct(t,e,r)}catch(a){if(a instanceof Error){m(3,"resolveDirectory error",{specifier:t,context:e,error:a});const s=a;if(s.code==="ERR_UNSUPPORTED_DIR_IMPORT"){const n=A(s);if(n)try{return await g(`${n}/index`,e,r,!0)}catch(i){const o=i,{message:d}=o;throw o.message=o.message.replace(`${"/index".replace("/",l.sep)}'`,"'"),o.stack=o.stack.replace(d,o.message),o}}}throw a}},"resolveDirectory"),mt=c(async(t,e,r)=>{if(m(3,"resolveTsPaths",{specifier:t,context:e,requestAcceptsQuery:F(t),tsconfigPathsMatcher:P,fromNodeModules:e.parentURL?.includes("/node_modules/")}),!F(t)&&P&&!e.parentURL?.includes("/node_modules/")){const a=P(t);m(3,"resolveTsPaths",{possiblePaths:a});for(const s of a)try{return await M(E(s).toString(),e,r)}catch{}}return M(t,e,r)},"resolveTsPaths"),D="tsx://";let v=c(async(t,e,r)=>{if(!p.active||t.startsWith("node:"))return r(t,e);let a=R(t)??(e.parentURL&&R(e.parentURL));if(p.namespace){let o;if(t.startsWith(D)){try{o=JSON.parse(t.slice(D.length))}catch{}o?.namespace&&(a=o.namespace)}if(p.namespace!==a)return r(t,e);o&&(t=o.specifier,e.parentURL=o.parentURL)}const[s,n]=t.split("?"),i=await mt(s,e,r);return m(2,"nextResolve",{resolved:i}),i.format==="builtin"||(!i.format&&i.url.startsWith(f)&&(i.format=await it(i.url),m(2,"getFormatFromFileUrl",{resolved:i,format:i.format})),n&&(i.url+=`?${n}`),a&&!i.url.includes(h)&&(i.url+=(i.url.includes("?")?"&":"?")+h+a)),i},"resolve");if(L){const t=v;v=c(async(e,r,a)=>{m(2,"resolve",{specifier:e,context:r});const s=await t(e,r,a);return m(1,"resolved",{specifier:e,context:r,result:s}),s},"resolve")}y(G)&&$&&H();export{at as globalPreload,et as initialize,U as load,v as resolve};
+The --loader flag was deprecated in Node v20.6.0 and v18.19.0`);p.namespace=t.namespace,t.tsconfig!==!1&&T(t.tsconfig??process.env.TSX_TSCONFIG_PATH),t.port&&(p.port=t.port,t.port.on("message",e=>{e==="deactivate"&&(p.active=!1,t.port.postMessage({type:"deactivated"}))}))},"initialize"),at=c(()=>(T(process.env.TSX_TSCONFIG_PATH),"process.setSourceMapsEnabled(true);"),"globalPreload"),u=new Map,st=c(async t=>{if(u.has(t))return u.get(t);if(!await O.promises.access(t).then(()=>!0,()=>!1)){u.set(t,void 0);return}const r=await O.promises.readFile(t,"utf8");try{const a=JSON.parse(r);return u.set(t,a),a}catch{throw new Error(`Error parsing: ${t}`)}},"readPackageJson"),rt=c(async t=>{let e=new URL("package.json",t);for(;!e.pathname.endsWith("/node_modules/package.json");){const r=k(e),a=await st(r);if(a)return a;const s=e;if(e=new URL("../package.json",e),e.pathname===s.pathname)break}},"findPackageJson"),ot=c(async t=>(await rt(t))?.type??"commonjs","getPackageType"),nt=c(t=>{[t]=t.split("?");const e=l.extname(t);if(e===".mts")return"module";if(e===".cts")return"commonjs"},"getFormatFromExtension"),it=c(t=>{const e=nt(t);if(e)return e;const{pathname:r}=new URL(t),a=l.extname(r);if(Q.includes(a))return ot(t)},"getFormatFromFileUrl"),h="tsx-namespace=",R=c(t=>{const e=t.indexOf(h);if(e===-1)return;const r=t[e-1];if(r!=="?"&&r!=="&")return;const a=e+h.length,s=t.indexOf("&",a);return s===-1?t.slice(a):t.slice(a,s)},"getNamespace"),W=y(q)?"importAttributes":"importAssertions";let U=c(async(t,e,r)=>{if(!p.active)return r(t,e);const a=R(t);if(p.namespace&&p.namespace!==a)return r(t,e);if(p.port){const o=new URL(t);o.searchParams.delete("tsx-namespace"),p.port.postMessage({type:"load",url:o.toString()})}if(j.send&&j.send({type:"dependency",path:t}),X.test(t)){let o=e[W];o||(o={},e[W]=o),o.type||(o.type="json")}const s=await r(t,e);m(3,"loaded by next loader",{url:t,loaded:s});const n=t.startsWith(f)?k(t):t;if(s.format==="commonjs"&&y(B)&&s.responseURL?.startsWith("file:")&&!n.endsWith(".cjs")){const o=await tt(new URL(t),"utf8");if(!n.endsWith(".js")||K(o)){const d=V(o,n,{tsconfigRaw:S?.(n)}),I=a?`${n}?namespace=${encodeURIComponent(a)}`:n;return s.responseURL=`data:text/javascript,${encodeURIComponent(d.code)}?filePath=${encodeURIComponent(I)}`,m(3,"returning CJS export annotation",s),s}}if(!s.source)return s;const i=s.source.toString();if(s.format==="json"||w.test(t)){const o=await Y(i,n,{tsconfigRaw:l.isAbsolute(n)?S?.(n):void 0});return{format:"module",source:_(o)}}if(s.format==="module"){const o=Z(n,i);o&&(s.source=_(o))}return s},"load");if(L){const t=U;U=c(async(e,r,a)=>{m(2,"load",{url:e,context:r});const s=await t(e,r,a);return m(1,"loaded",{url:e,result:s}),s},"load")}const A=c(t=>{if(t.url)return t.url;const e=t.message.match(/^Cannot find module '([^']+)'/);if(e){const[,a]=e;return a}const r=t.message.match(/^Cannot find package '([^']+)'/);if(r){const[,a]=r;if(!l.isAbsolute(a))return;const s=E(a);if(s.pathname.endsWith("/")&&(s.pathname+="package.json"),s.pathname.endsWith("/package.json")){const n=x(s);if(n?.main)return new URL(n.main,s).toString()}else return s.toString()}},"getMissingPathFromNotFound"),g=c(async(t,e,r,a)=>{const s=z(t);if(m(3,"resolveExtensions",{url:t,context:e,throwError:a,tryPaths:s}),!s)return;let n;for(const i of s)try{return await r(i,e)}catch(o){const{code:d}=o;if(d!=="ERR_MODULE_NOT_FOUND"&&d!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw o;n=o}if(a)throw n},"resolveExtensions"),ct=c(async(t,e,r)=>{if(m(3,"resolveBase",{specifier:t,context:e,specifierStartsWithFileUrl:t.startsWith(f),isRelativePath:J(t),tsExtensionsPattern:w.test(e.parentURL),allowJs:N}),(t.startsWith(f)||J(t))&&(w.test(e.parentURL)||N)){const a=await g(t,e,r);if(m(3,"resolveBase resolved",{specifier:t,context:e,resolved:a}),a)return a}try{return await r(t,e)}catch(a){if(m(3,"resolveBase error",{specifier:t,context:e,error:a}),a instanceof Error){const s=a;if(s.code==="ERR_MODULE_NOT_FOUND"){const n=A(s);if(n){const i=await g(n,e,r);if(i)return i}}}throw a}},"resolveBase"),M=c(async(t,e,r)=>{if(m(3,"resolveDirectory",{specifier:t,context:e,isDirectory:b.test(t)}),(t==="."||t===".."||t.endsWith("/.."))&&(t+="/"),b.test(t)){const a=new URL(t,e.parentURL);return a.pathname=l.join(a.pathname,"index"),await g(a.toString(),e,r,!0)}try{return await ct(t,e,r)}catch(a){if(a instanceof Error){m(3,"resolveDirectory error",{specifier:t,context:e,error:a});const s=a;if(s.code==="ERR_UNSUPPORTED_DIR_IMPORT"){const n=A(s);if(n)try{return await g(`${n}/index`,e,r,!0)}catch(i){const o=i,{message:d}=o;throw o.message=o.message.replace(`${"/index".replace("/",l.sep)}'`,"'"),o.stack=o.stack.replace(d,o.message),o}}}throw a}},"resolveDirectory"),mt=c(async(t,e,r)=>{if(m(3,"resolveTsPaths",{specifier:t,context:e,requestAcceptsQuery:F(t),tsconfigPathsMatcher:P,fromNodeModules:e.parentURL?.includes("/node_modules/")}),!F(t)&&P){const a=P(t);m(3,"resolveTsPaths",{possiblePaths:a});for(const s of a)try{return await M(E(s).toString(),e,r)}catch{}}return M(t,e,r)},"resolveTsPaths"),D="tsx://";let v=c(async(t,e,r)=>{if(!p.active||t.startsWith("node:"))return r(t,e);let a=R(t)??(e.parentURL&&R(e.parentURL));if(p.namespace){let o;if(t.startsWith(D)){try{o=JSON.parse(t.slice(D.length))}catch{}o?.namespace&&(a=o.namespace)}if(p.namespace!==a)return r(t,e);o&&(t=o.specifier,e.parentURL=o.parentURL)}const[s,n]=t.split("?"),i=await mt(s,e,r);return m(2,"nextResolve",{resolved:i}),i.format==="builtin"||(!i.format&&i.url.startsWith(f)&&(i.format=await it(i.url),m(2,"getFormatFromFileUrl",{resolved:i,format:i.format})),n&&(i.url+=`?${n}`),a&&!i.url.includes(h)&&(i.url+=(i.url.includes("?")?"&":"?")+h+a)),i},"resolve");if(L){const t=v;v=c(async(e,r,a)=>{m(2,"resolve",{specifier:e,context:r});const s=await t(e,r,a);return m(1,"resolved",{specifier:e,context:r,result:s}),s},"resolve")}y(G)&&$&&H();export{at as globalPreload,et as initialize,U as load,v as resolve};
