diff --git a/index.js b/index.js
index 67ed0b7af712c0b7e80d61c1b858e9f8279296a2..2c263c28d9943ad2815cc55bcfec81802516c6d5 100644
--- a/index.js
+++ b/index.js
@@ -55,16 +55,17 @@ const normalize = /([/\\]index)?(\.js)?$/
 // `Module._cache` like `@babel/register` -- a non-core module won't be in
 // `require.cache`. In that case this falls back to caching on the internal Map.
 class ExportsCache {
-  constructor () {
+  constructor (requireFn) {
     this._localCache = new Map() // <module filename or id> -> <exports>
     this._kRitmExports = Symbol('RitmExports')
+    this._require = requireFn;
   }
 
   has (filename, isBuiltin) {
     if (this._localCache.has(filename)) {
       return true
     } else if (!isBuiltin) {
-      const mod = require.cache[filename]
+      const mod = this._require.cache[filename];
       return !!(mod && this._kRitmExports in mod)
     } else {
       return false
@@ -76,7 +77,7 @@ class ExportsCache {
     if (cachedExports !== undefined) {
       return cachedExports
     } else if (!isBuiltin) {
-      const mod = require.cache[filename]
+      const mod = this._require.cache[filename];
       return (mod && mod[this._kRitmExports])
     }
   }
@@ -84,11 +85,14 @@ class ExportsCache {
   set (filename, exports, isBuiltin) {
     if (isBuiltin) {
       this._localCache.set(filename, exports)
-    } else if (filename in require.cache) {
-      require.cache[filename][this._kRitmExports] = exports
+    } else if (filename in this._require.cache) {
+      this._require.cache[filename][this._kRitmExports] = exports;
     } else {
-      debug('non-core module is unexpectedly not in require.cache: "%s"', filename)
-      this._localCache.set(filename, exports)
+      debug(
+        'non-core module is unexpectedly not in require.cache: "%s"',
+        filename,
+      );
+      this._localCache.set(filename, exports);
     }
   }
 }
@@ -110,10 +114,11 @@ function Hook (modules, options, onrequire) {
     return
   }
 
-  this._cache = new ExportsCache()
+  this._origRequire = Module.prototype.require;
+
+  this._cache = new ExportsCache(this._origRequire);
 
   this._unhooked = false
-  this._origRequire = Module.prototype.require
 
   const self = this
   const patching = new Set()
